import { preferences } from '@kit.ArkData';
import { common } from '@kit.AbilityKit';
import { GameState } from '../models/GameState';

/**
 * ä¿å­˜çš„æ¸¸æˆçŠ¶æ€æ¥å£
 */
export interface SavedGameState {
  gameMode: string;
  gridSize: number;
  moveCount: number;
  timeElapsed: number;
  isPlaying: boolean;
  timestamp?: number;  // ğŸ”¥ ä¿å­˜æ—¶é—´æˆ³ï¼Œç”¨äºæ£€æµ‹è¿‡æœŸæ•°æ®
}

/**
 * æœ€ä½³è®°å½•æ¥å£
 */
export interface BestRecord {
  moveCount: number;
  timeElapsed: number;
}

/**
 * æ¸¸æˆæ•°æ®æŒä¹…åŒ–å·¥å…·
 * ç¬¦åˆArkTSè§„èŒƒï¼šä½¿ç”¨AppStorageè·å–context
 */
export class GameStorage {
  private static context: common.Context | null = null;
  private static readonly PREFERENCES_NAME = 'puzzle_game_prefs';
  private static readonly KEY_GAME_STATE = 'game_state';
  private static readonly KEY_BEST_RECORD = 'best_record';

  /**
   * è®¾ç½®ä¸Šä¸‹æ–‡ï¼Œæ”¯æŒè·¨è¿›ç¨‹ï¼ˆå¦‚FormAbilityï¼‰æ˜¾å¼æ³¨å…¥
   */
  static setContext(context: common.Context): void {
    GameStorage.context = context;
  }

  /**
   * è·å–ä¸Šä¸‹æ–‡ï¼šä¼˜å…ˆè¿”å›æ˜¾å¼æ³¨å…¥ï¼Œå…¶æ¬¡å°è¯•ä»AppStorageè¯»å–
   */
  private static getContext(): common.Context {
    if (GameStorage.context) {
      return GameStorage.context;
    }
    const storedContext = AppStorage.get<common.UIAbilityContext>('context');
    if (storedContext) {
      GameStorage.context = storedContext;
      return storedContext;
    }
    throw new Error('Contextæœªåˆå§‹åŒ–ï¼Œè¯·åœ¨EntryAbilityä¸­ä¿å­˜contextæˆ–åœ¨ä½¿ç”¨å‰è°ƒç”¨GameStorage.setContext');
  }

  /**
   * ä¿å­˜æ¸¸æˆçŠ¶æ€
   */
  static async saveGameState(state: SavedGameState): Promise<void> {
    try {
      const context = GameStorage.getContext();
      const prefs = await preferences.getPreferences(context, GameStorage.PREFERENCES_NAME);
      await prefs.put(GameStorage.KEY_GAME_STATE, JSON.stringify(state));
      await prefs.flush();
      console.info('æ¸¸æˆçŠ¶æ€å·²ä¿å­˜');
    } catch (error) {
      console.error('ä¿å­˜æ¸¸æˆçŠ¶æ€å¤±è´¥:', error);
    }
  }

  /**
   * è¯»å–æ¸¸æˆçŠ¶æ€
   */
  static async loadGameState(): Promise<SavedGameState | null> {
    try {
      const context = GameStorage.getContext();
      const prefs = await preferences.getPreferences(context, GameStorage.PREFERENCES_NAME);
      const stateStr = await prefs.get(GameStorage.KEY_GAME_STATE, '');
      
      if (stateStr) {
        return JSON.parse(stateStr as string) as SavedGameState;
      }
      return null;
    } catch (error) {
      console.error('è¯»å–æ¸¸æˆçŠ¶æ€å¤±è´¥:', error);
      return null;
    }
  }

  /**
   * æ¸…é™¤æ¸¸æˆçŠ¶æ€
   */
  static async clearGameState(): Promise<void> {
    try {
      const context = GameStorage.getContext();
      const prefs = await preferences.getPreferences(context, GameStorage.PREFERENCES_NAME);
      await prefs.delete(GameStorage.KEY_GAME_STATE);
      await prefs.flush();
      console.info('æ¸¸æˆçŠ¶æ€å·²æ¸…é™¤');
    } catch (error) {
      console.error('æ¸…é™¤æ¸¸æˆçŠ¶æ€å¤±è´¥:', error);
    }
  }

  /**
   * ä¿å­˜æœ€ä½³è®°å½•
   */
  static async saveBestRecord(gridSize: number, moveCount: number, timeElapsed: number): Promise<void> {
    try {
      const context = GameStorage.getContext();
      const prefs = await preferences.getPreferences(context, GameStorage.PREFERENCES_NAME);
      const key = `best_${gridSize}x${gridSize}`;
      
      // è¯»å–ç°æœ‰è®°å½•
      const existing = await prefs.get(key, '');
      let shouldSave = true;
      
      if (existing) {
        const existingRecord = JSON.parse(existing as string) as BestRecord;
        // åªæœ‰æ›´å¥½çš„æˆç»©æ‰ä¿å­˜ï¼ˆæ›´å°‘æ­¥æ•°æˆ–æ›´çŸ­æ—¶é—´ï¼‰
        if (existingRecord.moveCount < moveCount || existingRecord.timeElapsed < timeElapsed) {
          shouldSave = false;
        }
      }
      
      if (shouldSave) {
        await prefs.put(key, JSON.stringify({ moveCount, timeElapsed }));
        await prefs.flush();
        console.info('æœ€ä½³è®°å½•å·²æ›´æ–°');
      }
    } catch (error) {
      console.error('ä¿å­˜æœ€ä½³è®°å½•å¤±è´¥:', error);
    }
  }

  /**
   * è¯»å–æœ€ä½³è®°å½•
   */
  static async loadBestRecord(gridSize: number): Promise<BestRecord | null> {
    try {
      const context = GameStorage.getContext();
      const prefs = await preferences.getPreferences(context, GameStorage.PREFERENCES_NAME);
      const key = `best_${gridSize}x${gridSize}`;
      const recordStr = await prefs.get(key, '');
      
      if (recordStr) {
        return JSON.parse(recordStr as string) as BestRecord;
      }
      return null;
    } catch (error) {
      console.error('è¯»å–æœ€ä½³è®°å½•å¤±è´¥:', error);
      return null;
    }
  }
}
