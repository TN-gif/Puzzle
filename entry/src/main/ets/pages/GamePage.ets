import { router, font, display } from '@kit.ArkUI';
import { image } from '@kit.ImageKit';
import { TileData } from '../models/TileData';
import { ImageSlicer } from '../utils/ImageSlicer';
import { ShuffleHelper } from '../utils/ShuffleHelper';
import { WinChecker } from '../utils/WinChecker';
import { UriConverter } from '../utils/UriConverter';
import { SoundService } from '../utils/SoundService';
import { GameStorage, SavedGameState } from '../utils/GameStorage';
import { GameConstants } from '../constants/GameConstants';
import { DesignConstants } from '../constants/DesignConstants';
import { ScreenState, ScreenStateManager } from '../utils/ScreenStateManager';
import { WinDialog } from '../components/WinDialog';
import { DifficultyDialog } from '../components/DifficultyDialog';
import { ImageCache } from '../utils/ImageCache';
import { formProvider, formBindingData } from '@kit.FormKit';
import { preferences } from '@kit.ArkData';
import { common } from '@kit.AbilityKit';
import { audioManager } from '../utils/AudioManager';
import { SoundButton } from '../components/SoundButton';

/**
 * è·¯ç”±å‚æ•°æ¥å£
 */
interface GamePageParams {
  gameMode: string;
  gridSize: number;
  imageResource: Resource | string;
  isCustomImage: boolean;
  isNetworkImage: boolean;
  useCachedImage?: boolean;  // æ˜¯å¦ä½¿ç”¨ç¼“å­˜çš„è£å‰ªåå›¾ç‰‡
  fromPage?: string;  // æ¥æºé¡µé¢
  source?: string;  // å›¾ç‰‡æ¥æºï¼ˆç”¨äºéŸ³ä¹æ’­æ”¾ï¼‰
  characterId?: string;  // è§’è‰²IDï¼ˆç”¨äºéŸ³ä¹æ’­æ”¾ï¼‰
}

/**
 * å¡ç‰‡æ•°æ®æ¥å£
 */
interface FormDataContent {
  title: string;
  gameMode: string;
  gridSize: string;
  moveCount: number;
  timeElapsed: string;
  hasActiveGame: boolean;
}

/**
 * ä½ç½®æ¥å£
 */
interface Position {
  x: number;
  y: number;
}

/**
 * å›¾ç‰‡å°ºå¯¸æ¥å£
 */
interface ImageSize {
  x: number;
  y: number;
  width: number;
  height: number;
}

/**
 * æŒ‰é’®å°ºå¯¸æ¥å£
 */
interface ButtonSize {
  width: number;
  height: number;
}

/**
 * æŒ‰é’®ä½ç½®é…ç½®æ¥å£
 */
interface GameButtonPositions {
  mode: Position;
  difficulty: Position;
  peek: Position;
  restart: Position;
  image: ImageSize;
  back: Position;
}

/**
 * æ¸¸æˆé¡µï¼šæ‹¼å›¾æ¸¸æˆæ ¸å¿ƒé€»è¾‘
 */
@Entry
@Component
struct GamePage {
  // è·¯ç”±å‚æ•°
  @State gameMode: string = GameConstants.GAME_MODE.SWAP;
  @State gridSize: number = 3;
  @State imageResource: Resource | string = '';
  @State isCustomImage: boolean = false;
  @State isNetworkImage: boolean = false;
  @State useCachedImage: boolean = false;  // æ˜¯å¦ä½¿ç”¨ç¼“å­˜çš„è£å‰ªåå›¾ç‰‡
  @State fromPage: string = '';  // æ¥æºé¡µé¢
  @State source: string = '';  // å›¾ç‰‡æ¥æºï¼ˆç”¨äºéŸ³ä¹æ’­æ”¾ï¼‰
  @State characterId: string = '';  // è§’è‰²IDï¼ˆç”¨äºéŸ³ä¹æ’­æ”¾ï¼‰
  
  // ğŸ”¥ å¡ç‰‡è·³è½¬ç›‘å¬
  @StorageProp('widgetTargetPage') widgetTargetPage: string = '';
  @StorageProp('widgetTargetPageTimestamp') widgetTargetPageTimestamp: number = 0;
  private lastProcessedTimestamp: number = 0;  // è®°å½•å·²å¤„ç†çš„è·³è½¬è¯·æ±‚

  // æ¸¸æˆçŠ¶æ€
  @State tiles: TileData[] = [];
  @State emptyIndex: number = 8;
  @State moveCount: number = 0;
  @State timeElapsed: number = 0;
  @State isPlaying: boolean = false;
  @State originalPixelMap: image.PixelMap | null = null;

  // UIçŠ¶æ€
  @State isPeeking: boolean = false;
  @State gridGap: number = GameConstants.GRID_GAP;
  @State draggedTileIndex: number = -1;
  @State selectedTileIndex: number = -1;
  @State screenState: ScreenState = ScreenState.TRIPLE;
  @State isDragging: boolean = false;  // æ˜¯å¦æ­£åœ¨æ‹–æ‹½
  @State dragStartX: number = 0;  // æ‹–æ‹½èµ·å§‹Xåæ ‡
  @State dragStartY: number = 0;  // æ‹–æ‹½èµ·å§‹Yåæ ‡
  @State dragOffsetX: number = 0;  // æ‹–æ‹½Xåç§»
  @State dragOffsetY: number = 0;  // æ‹–æ‹½Yåç§»
  
  // Gridç»„ä»¶çš„å®é™…ä½ç½®å’Œå°ºå¯¸ï¼ˆé€šè¿‡onAreaChangeåŠ¨æ€è·å–ï¼‰
  @State gridPositionX: number = 0;  // Gridåœ¨å±å¹•ä¸Šçš„Xåæ ‡
  @State gridPositionY: number = 0;  // Gridåœ¨å±å¹•ä¸Šçš„Yåæ ‡
  @State gridActualSize: number = 0;  // Gridçš„å®é™…å°ºå¯¸
  
  // å®é™…å±å¹•å°ºå¯¸ï¼ˆç”¨äºå“åº”å¼ç¼©æ”¾ï¼‰
  @State actualWidth: number = 1107;
  @State actualHeight: number = 776;
  
  // å·çœ‹ç­”æ¡ˆå‰çš„çŠ¶æ€ä¿å­˜
  private savedTilesBeforePeek: TileData[] = [];
  private savedEmptyIndexBeforePeek: number = -1;

  // å®šæ—¶å™¨
  private timerInterval: number = -1;
  private screenManager: ScreenStateManager = ScreenStateManager.getInstance();

  // èƒœåˆ©å¯¹è¯æ¡†
  private winDialogController: CustomDialogController = new CustomDialogController({
    builder: WinDialog({
      moveCount: this.moveCount,
      timeElapsed: this.timeElapsed,
      onPlayAgain: () => {
        this.restartGame();
      },
      onBackHome: () => {
        this.goBackHome();
      }
    }),
    autoCancel: false,
    customStyle: true
  });

  // éš¾åº¦é€‰æ‹©å¯¹è¯æ¡†
  private difficultyDialogController: CustomDialogController = new CustomDialogController({
    builder: DifficultyDialog({
      selectedDifficulty: this.gridSize,
      onDifficultySelected: (difficulty: number) => {
        this.changeDifficulty(difficulty);
      }
    }),
    autoCancel: true,
    customStyle: true
  });

  async aboutToAppear() {
    // è·å–è·¯ç”±å‚æ•°
    const params = router.getParams() as GamePageParams;

    if (params) {
      this.gameMode = params.gameMode || GameConstants.GAME_MODE.SWAP;
      this.gridSize = params.gridSize || 3;
      this.imageResource = params.imageResource;
      this.isCustomImage = params.isCustomImage || false;
      this.isNetworkImage = params.isNetworkImage || false;
      this.useCachedImage = params.useCachedImage || false;
      this.fromPage = params.fromPage || '';
      this.source = params.source || '';
      this.characterId = params.characterId || '';
    }
    
    // ğŸ”¥ å®˜æ–¹ç¡®è®¤æ–¹æ¡ˆï¼šæ£€æµ‹æ— æ•ˆå¯åŠ¨å¹¶åŒæ•°æ®æºæ¸…é™¤
    if (!params || !this.imageResource) {
      console.warn('[GamePage] âš ï¸ æ£€æµ‹åˆ°æ— æ•ˆå¯åŠ¨ï¼ˆåº”ç”¨è¢«æ¸…é™¤åä»å¡ç‰‡å¯åŠ¨ï¼‰');
      console.info('[GamePage] ğŸ“Š å¯åŠ¨è¯Šæ–­ä¿¡æ¯:');
      console.info('[GamePage]   - è·¯ç”±å‚æ•°: %{public}s', params ? 'exists' : 'null');
      console.info('[GamePage]   - å›¾ç‰‡èµ„æº: %{public}s', this.imageResource ? 'exists' : 'null');
      
      const lastLaunchTime = AppStorage.get<number>('lastLaunchTime') || 0;
      const currentTime = Date.now();
      console.info('[GamePage]   - å¯åŠ¨æ—¶é—´å·®: %{public}d ms', currentTime - lastLaunchTime);
      
      console.info('[GamePage] ğŸ§¹ å¼€å§‹æ¸…ç†æ®‹ç•™æ•°æ®ï¼ˆåŒæ•°æ®æºåŒæ­¥æ¸…é™¤ï¼‰...');
      
      // ğŸ”¥ å…³é”®ï¼šåŒæ—¶æ¸…é™¤ AppStorageï¼ˆå†…å­˜ï¼‰å’Œ preferencesï¼ˆç£ç›˜ï¼‰
      AppStorage.setOrCreate('currentGameState', null);
      await GameStorage.clearGameState();
      
      console.info('[GamePage] âœ… æ•°æ®æ¸…ç†å®Œæˆ');
      
      // ğŸ”¥ ç«‹å³æ›´æ–°æ‰€æœ‰å¡ç‰‡ï¼ˆæ˜¾ç¤º"å¼€å§‹æ–°æ¸¸æˆ"ï¼‰
      await this.updateAllFormsAfterClear();
      
      console.info('[GamePage] ğŸ  è¿”å›ä¸»é¡µ');
      
      router.replaceUrl({
        url: 'pages/EntryPage'
      }).catch((err: Error) => {
        console.error('[GamePage] âŒ è¿”å›ä¸»é¡µå¤±è´¥:', err);
      });
      
      return;  // é˜»æ­¢ç»§ç»­æ‰§è¡Œ
    }

    // ç›‘å¬å±å¹•çŠ¶æ€å˜åŒ–
    this.screenManager.addListener((state: ScreenState) => {
      this.screenState = state;
      this.updateScreenSize();
    });
    this.screenState = this.screenManager.getCurrentState();
    this.updateScreenSize();

    // æ³¨å†Œè‡ªå®šä¹‰å­—ä½“
    font.registerFont({
      familyName: 'Muyao-Softbrush',
      familySrc: `/resources/rawfile/${DesignConstants.CUSTOM_FONT_PATH}`
    });

    // æ’­æ”¾èƒŒæ™¯éŸ³ä¹
    this.playBackgroundMusic();

    // åˆå§‹åŒ–æ¸¸æˆ
    await this.initGame();
    
    // ğŸ”¥ æ–°å¢ï¼šæ£€æŸ¥æ˜¯å¦æœ‰å¡ç‰‡è·³è½¬è¯·æ±‚
    this.checkWidgetNavigation();
  }
  
  // æ›´æ–°å®é™…å±å¹•å°ºå¯¸
  private updateScreenSize(): void {
    const displayClass = display.getDefaultDisplaySync();
    this.actualWidth = displayClass.width;
    this.actualHeight = displayClass.height;
    console.info(`[GamePage] å®é™…å±å¹•å°ºå¯¸: ${this.actualWidth}Ã—${this.actualHeight}`);
  }
  
  /**
   * æ ¹æ®æ¥æºæ’­æ”¾å¯¹åº”çš„èƒŒæ™¯éŸ³ä¹
   */
  private playBackgroundMusic(): void {
    let musicPath = '';
    
    if (this.source === 'network' || this.source === 'gallery') {
      // ç½‘ç»œéšæœºæˆ–ç›¸å†Œä¸Šä¼ 
      musicPath = 'music/ç½‘ç»œä¸ç›¸å†Œ.mp3';
    } else if (this.source === 'bangbu') {
      // é‚¦å¸ƒä¸“è¾‘
      musicPath = 'music/é‚¦å¸ƒ.mp3';
    } else if (this.source === 'character') {
      // è§’è‰²ä¸“è¾‘ï¼šæ ¹æ® characterId é€‰æ‹©éŸ³ä¹
      if (this.characterId === 'laite') {
        musicPath = 'music/è±ç‰¹.mp3';
      } else if (this.characterId === 'weiweian') {
        musicPath = 'music/è–‡è–‡å®‰.mp3';
      }
    }
    
    if (musicPath) {
      audioManager.playBGM(musicPath);
      console.info(`[GamePage] æ’­æ”¾èƒŒæ™¯éŸ³ä¹: ${musicPath}`);
    }
  }

  /**
   * å®æ—¶ä¿å­˜å½“å‰æ¸¸æˆçŠ¶æ€
   * ğŸ”¥ å¼ºç¡¬æ‰‹æ®µï¼šåŒæ—¶ä¿å­˜åˆ° AppStorageï¼ˆå†…å­˜ï¼Œç«‹å³ç”Ÿæ•ˆï¼‰å’Œ preferencesï¼ˆæŒä¹…åŒ–ï¼Œå¼‚æ­¥ï¼‰
   */
  private saveCurrentGameState(): void {
    if (this.isPlaying && (this.moveCount > 0 || this.timeElapsed > 0)) {
      // ğŸ”¥ ä½¿ç”¨æ˜¾å¼ç±»å‹å£°æ˜ï¼Œç¬¦åˆ ArkTS è§„èŒƒ
      const gameState: SavedGameState = {
        gameMode: this.gameMode,
        gridSize: this.gridSize,
        moveCount: this.moveCount,
        timeElapsed: this.timeElapsed,
        isPlaying: this.isPlaying,
        timestamp: Date.now()  // ğŸ”¥ æ·»åŠ æ—¶é—´æˆ³ï¼Œç”¨äºè¿‡æœŸæ£€æµ‹
      };
      
      // ğŸ”¥ å…³é”®1ï¼šç«‹å³åŒæ­¥åˆ° AppStorageï¼ˆå†…å­˜ï¼Œé›¶å»¶è¿Ÿï¼‰
      AppStorage.setOrCreate('currentGameState', gameState);
      console.info('[GamePage] âš¡ AppStorageå·²æ›´æ–°: æ­¥æ•°=' + this.moveCount + ', ç”¨æ—¶=' + this.timeElapsed);
      
      // ğŸ”¥ å…³é”®2ï¼šå¼‚æ­¥ä¿å­˜åˆ° preferencesï¼ˆæŒä¹…åŒ–å¤‡ä»½ï¼‰
      GameStorage.saveGameState(gameState);
    }
  }

  aboutToDisappear() {
    // é¡µé¢é”€æ¯æ—¶å†æ¬¡ä¿å­˜ï¼ˆç¡®ä¿çŠ¶æ€æœ€æ–°ï¼‰
    this.saveCurrentGameState();

    // æ¸…ç†å®šæ—¶å™¨
    if (this.timerInterval !== -1) {
      clearInterval(this.timerInterval);
    }

    // ç§»é™¤ç›‘å¬å™¨
    this.screenManager.removeListener((state: ScreenState) => {
      this.screenState = state;
    });
  }
  
  // ğŸ”¥ æ–°å¢ï¼šé¡µé¢æ˜¾ç¤ºæ—¶æ£€æŸ¥å¡ç‰‡è·³è½¬
  onPageShow() {
    console.info('[GamePage] ğŸ“º é¡µé¢æ˜¾ç¤ºï¼Œæ£€æŸ¥å¡ç‰‡è·³è½¬è¯·æ±‚...');
    this.checkWidgetNavigation();
    
    // ç¡®ä¿éŸ³ä¹æ’­æ”¾
    audioManager.resumeBGM();
  }
  
  // ğŸ”¥ æ–°å¢æ–¹æ³•ï¼šæ£€æŸ¥å¹¶å¤„ç†å¡ç‰‡è·³è½¬ï¼ˆå¸¦æ—¶é—´æˆ³æ ¡éªŒï¼‰
  private checkWidgetNavigation(): void {
    // åªå¤„ç†æ–°çš„è·³è½¬è¯·æ±‚ï¼ˆé€šè¿‡æ—¶é—´æˆ³åˆ¤æ–­ï¼Œé¿å…é‡å¤è·³è½¬ï¼‰
    if (this.widgetTargetPage && 
        this.widgetTargetPageTimestamp > 0 && 
        this.widgetTargetPageTimestamp !== this.lastProcessedTimestamp) {
      
      console.info(`[GamePage] ğŸ¯ æ£€æµ‹åˆ°å¡ç‰‡è·³è½¬è¯·æ±‚:`);
      console.info(`[GamePage]   - ç›®æ ‡é¡µé¢: ${this.widgetTargetPage}`);
      console.info(`[GamePage]   - è¯·æ±‚æ—¶é—´æˆ³: ${this.widgetTargetPageTimestamp}`);
      console.info(`[GamePage]   - ä¸Šæ¬¡å¤„ç†æ—¶é—´æˆ³: ${this.lastProcessedTimestamp}`);
      
      // å¦‚æœç›®æ ‡é¡µé¢ä¸æ˜¯å½“å‰é¡µé¢ï¼Œåˆ™è·³è½¬
      if (this.widgetTargetPage !== 'pages/GamePage') {
        console.info(`[GamePage] ğŸš€ æ‰§è¡Œè·³è½¬åˆ°: ${this.widgetTargetPage}`);
        
        // ğŸ”¥ å…³é”®ï¼šå…ˆç”¨å±€éƒ¨å˜é‡ä¿å­˜ç›®æ ‡é¡µé¢ï¼ˆé˜²æ­¢æ¸…ç©ºAppStorageåä¸¢å¤±ï¼‰
        const targetPageToNavigate = this.widgetTargetPage;
        
        // ğŸ”¥ å®˜æ–¹å»ºè®®ï¼šè®°å½•å·²å¤„ç†çš„æ—¶é—´æˆ³
        this.lastProcessedTimestamp = this.widgetTargetPageTimestamp;
        
        // æ¸…é™¤æ ‡è®°ï¼Œé¿å…é‡å¤è·³è½¬
        AppStorage.setOrCreate('widgetTargetPage', '');
        AppStorage.setOrCreate('widgetTargetPageTimestamp', 0);
        
        // æ‰§è¡Œè·³è½¬ï¼ˆå»¶è¿Ÿç¡®ä¿é¡µé¢å®Œå…¨åŠ è½½ï¼‰
        setTimeout(() => {
          router.pushUrl({
            url: targetPageToNavigate
          }).then(() => {
            console.info(`[GamePage] âœ… è·³è½¬æˆåŠŸ: ${targetPageToNavigate}`);
          }).catch((err: Error) => {
            console.error(`[GamePage] âŒ è·³è½¬å¤±è´¥: ${err.message}`);
          });
        }, 100);
      } else {
        console.info(`[GamePage] â„¹ï¸ ç›®æ ‡é¡µé¢æ˜¯å½“å‰é¡µé¢ï¼Œå¿½ç•¥è·³è½¬`);
        // è®°å½•å·²å¤„ç†å¹¶æ¸…é™¤æ ‡è®°
        this.lastProcessedTimestamp = this.widgetTargetPageTimestamp;
        AppStorage.setOrCreate('widgetTargetPage', '');
        AppStorage.setOrCreate('widgetTargetPageTimestamp', 0);
      }
    } else {
      console.info('[GamePage] â„¹ï¸ æ— å¾…å¤„ç†çš„å¡ç‰‡è·³è½¬è¯·æ±‚');
    }
  }

  // åˆå§‹åŒ–æ¸¸æˆ
  private async initGame(): Promise<void> {
    try {
      console.info('[GamePage] å¼€å§‹åˆå§‹åŒ–æ¸¸æˆ');
      console.info(`[GamePage] isNetworkImage: ${this.isNetworkImage}, isCustomImage: ${this.isCustomImage}`);
      console.info(`[GamePage] useCachedImage: ${this.useCachedImage}`);
      console.info(`[GamePage] imageResource: ${this.imageResource}`);
      
      // åŠ è½½å›¾ç‰‡
      let pixelMap: image.PixelMap;
      
      // ä¼˜å…ˆæ£€æŸ¥æ˜¯å¦ä½¿ç”¨ç¼“å­˜çš„è£å‰ªåå›¾ç‰‡
      if (this.useCachedImage && ImageCache.has()) {
        console.info('[GamePage] âœ… ä½¿ç”¨ç¼“å­˜çš„è£å‰ªåå›¾ç‰‡ï¼ˆæ‰€è§å³æ‰€å¾—ï¼‰');
        pixelMap = ImageCache.get()!;
        console.info('[GamePage] ç¼“å­˜å›¾ç‰‡è·å–æˆåŠŸ');
      } else if (this.isNetworkImage && typeof this.imageResource === 'string') {
        // ç½‘ç»œå›¾ç‰‡
        console.info('[GamePage] åŠ è½½ç½‘ç»œå›¾ç‰‡:', this.imageResource);
        pixelMap = await UriConverter.urlToPixelMap(this.imageResource);
        console.info('[GamePage] ç½‘ç»œå›¾ç‰‡åŠ è½½æˆåŠŸ');
      } else if (this.isCustomImage && typeof this.imageResource === 'string') {
        // ç›¸å†Œå›¾ç‰‡æˆ–rawfileå›¾ç‰‡
        if (this.imageResource.startsWith('file://') || this.imageResource.startsWith('content://')) {
          console.info('[GamePage] åŠ è½½ç›¸å†Œå›¾ç‰‡:', this.imageResource);
        pixelMap = await UriConverter.uriToPixelMap(this.imageResource);
          console.info('[GamePage] ç›¸å†Œå›¾ç‰‡åŠ è½½æˆåŠŸ');
        } else if (this.imageResource.startsWith('http://') || this.imageResource.startsWith('https://')) {
          // å¦‚æœæ˜¯httpå¼€å¤´ä½†è¢«æ ‡è®°ä¸ºcustomImageï¼ŒæŒ‰ç½‘ç»œå›¾ç‰‡å¤„ç†
          console.info('[GamePage] åŠ è½½ç½‘ç»œå›¾ç‰‡(æ ‡è®°ä¸ºcustom):', this.imageResource);
          pixelMap = await UriConverter.urlToPixelMap(this.imageResource);
          console.info('[GamePage] ç½‘ç»œå›¾ç‰‡åŠ è½½æˆåŠŸ');
        } else {
          // rawfileè·¯å¾„
          console.info('[GamePage] åŠ è½½rawfileå›¾ç‰‡:', this.imageResource);
          pixelMap = await UriConverter.rawfileToPixelMap(this.imageResource);
          console.info('[GamePage] rawfileå›¾ç‰‡åŠ è½½æˆåŠŸ');
        }
      } else {
        // é¢„è®¾å›¾ç‰‡
        console.info('[GamePage] åŠ è½½é¢„è®¾å›¾ç‰‡');
        pixelMap = await UriConverter.resourceToPixelMap(this.imageResource as Resource);
        console.info('[GamePage] é¢„è®¾å›¾ç‰‡åŠ è½½æˆåŠŸ');
      }

      console.info('[GamePage] å›¾ç‰‡åŠ è½½å®Œæˆï¼Œå¼€å§‹åˆ‡å‰²');
      this.originalPixelMap = pixelMap;

      // åˆ‡å‰²å›¾ç‰‡ï¼ˆæ ¹æ®æ¸¸æˆæ¨¡å¼å†³å®šæ˜¯å¦åˆ›å»ºç©ºæ ¼ï¼‰
      const createEmpty = (this.gameMode === GameConstants.GAME_MODE.HUARONG);
      const tilesData = await ImageSlicer.sliceImage(pixelMap, this.gridSize, createEmpty);
      this.tiles = tilesData;
      this.emptyIndex = this.gridSize * this.gridSize - 1;
      
      console.info(`[GamePage] å›¾ç‰‡åˆ‡å‰²å®Œæˆï¼Œå…± ${this.tiles.length} ä¸ªæ–¹å—`);

      // æ˜¾ç¤ºå®Œæ•´æ‹¼å›¾1ç§’åå¼€å§‹æ´—ç‰Œ
      setTimeout(() => {
        this.shuffleWithAnimation();
      }, 1000);

    } catch (error) {
      console.error('[GamePage] åˆå§‹åŒ–æ¸¸æˆå¤±è´¥:', error);
      console.error('[GamePage] é”™è¯¯è¯¦æƒ…:', JSON.stringify(error));
      
      // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ ç”¨æˆ·æç¤º
      // æ¯”å¦‚ä½¿ç”¨Toastæˆ–Dialogå‘ŠçŸ¥ç”¨æˆ·å›¾ç‰‡åŠ è½½å¤±è´¥
    }
  }

  // å¸¦åŠ¨ç”»çš„æ´—ç‰Œ
  private shuffleWithAnimation(): void {
    if (this.gameMode === GameConstants.GAME_MODE.HUARONG) {
      // åå®¹é“æ¨¡å¼ï¼šä½¿ç”¨ä¼ ç»Ÿæ´—ç‰Œ
      const result = ShuffleHelper.shuffle(this.tiles, this.gridSize);
      
      animateTo({
        duration: GameConstants.ANIMATION_DURATION.TILE_MOVE,
        curve: Curve.EaseOut
      }, () => {
        this.tiles = result.tiles;
        this.emptyIndex = result.emptyIndex;
      });
    } else {
      // äº¤æ¢æ¨¡å¼ï¼šå®Œå…¨éšæœºæ‰“ä¹±
      const shuffledTiles = ShuffleHelper.shuffleForSwapMode(this.tiles, this.gridSize);
      
      animateTo({
        duration: GameConstants.ANIMATION_DURATION.TILE_MOVE,
        curve: Curve.EaseOut
      }, () => {
        this.tiles = shuffledTiles;
      });
    }

    // æ´—ç‰Œå®Œæˆåå¼€å§‹è®¡æ—¶
    setTimeout(() => {
      this.startTimer();
    }, GameConstants.ANIMATION_DURATION.TILE_MOVE);
  }

  // å¼€å§‹è®¡æ—¶
  private startTimer(): void {
    this.isPlaying = true;
    this.timerInterval = setInterval(() => {
      if (this.isPlaying) {
        this.timeElapsed++;
        // æ¯ç§’ä¿å­˜ä¸€æ¬¡çŠ¶æ€ï¼Œç¡®ä¿æ—¶é—´ä¹Ÿèƒ½å®æ—¶åŒæ­¥åˆ°å¡ç‰‡
        this.saveCurrentGameState();
      }
    }, 1000);
  }

  // ç‚¹å‡»æ–¹å—
  private onTileClick(index: number): void {
    if (!this.isPlaying) return;
    if (this.tiles[index].isEmpty) return;
    
    // äº¤æ¢æ¨¡å¼ï¼šå›ºå®šçš„æç¤ºæ–¹å—ä¸èƒ½è¢«ç‚¹å‡»
    if (this.gameMode === GameConstants.GAME_MODE.SWAP && this.tiles[index].isHint) {
      return;
    }

    if (this.gameMode === GameConstants.GAME_MODE.HUARONG) {
      // åå®¹é“æ¨¡å¼ï¼šæ£€æŸ¥æ˜¯å¦ç›¸é‚»
      if (ShuffleHelper.isAdjacent(index, this.emptyIndex, this.gridSize)) {
        this.moveTile(index);
      }
    } else {
      // äº¤æ¢æ¨¡å¼ï¼šé€‰æ‹©æ–¹å—ç”¨äºäº¤æ¢
      if (this.selectedTileIndex === -1) {
        this.selectedTileIndex = index;
      } else {
        if (this.selectedTileIndex !== index) {
          this.swapTiles(this.selectedTileIndex, index);
        }
        this.selectedTileIndex = -1;
      }
    }
  }

  // äº¤æ¢ä¸¤ä¸ªæ–¹å—ï¼ˆäº¤æ¢æ¨¡å¼ï¼‰
  private swapTiles(index1: number, index2: number): void {
    // æ£€æŸ¥æ˜¯å¦ä¸ºå›ºå®šçš„æç¤ºæ–¹å—
    if (this.tiles[index1].isHint || this.tiles[index2].isHint) {
      return;
    }
    
    SoundService.playMoveSound();

    animateTo({
      duration: GameConstants.ANIMATION_DURATION.TILE_MOVE,
      curve: Curve.EaseOut
    }, () => {
      const temp = this.tiles[index1];
      this.tiles[index1] = this.tiles[index2];
      this.tiles[index2] = temp;

      this.tiles[index1].currentIndex = index1;
      this.tiles[index2].currentIndex = index2;

      this.moveCount++;
      
      // ğŸ”¥ å…³é”®ï¼šæ¯æ¬¡ç§»åŠ¨åç«‹å³ä¿å­˜çŠ¶æ€ï¼Œç¡®ä¿æŒ‰Homeé”®æ—¶èƒ½è¯»å–åˆ°æœ€æ–°è¿›åº¦
      this.saveCurrentGameState();
    });

    setTimeout(() => {
      this.checkWin();
    }, GameConstants.ANIMATION_DURATION.TILE_MOVE);
  }


  // ç§»åŠ¨æ–¹å—
  private moveTile(index: number): void {
    SoundService.playMoveSound();

    animateTo({
      duration: GameConstants.ANIMATION_DURATION.TILE_MOVE,
      curve: Curve.EaseOut
    }, () => {
      const temp = this.tiles[index];
      this.tiles[index] = this.tiles[this.emptyIndex];
      this.tiles[this.emptyIndex] = temp;

      this.tiles[index].currentIndex = index;
      this.tiles[this.emptyIndex].currentIndex = this.emptyIndex;

      this.emptyIndex = index;
      this.moveCount++;
      
      // ğŸ”¥ å…³é”®ï¼šæ¯æ¬¡ç§»åŠ¨åç«‹å³ä¿å­˜çŠ¶æ€ï¼Œç¡®ä¿æŒ‰Homeé”®æ—¶èƒ½è¯»å–åˆ°æœ€æ–°è¿›åº¦
      this.saveCurrentGameState();
    });

    setTimeout(() => {
      this.checkWin();
    }, GameConstants.ANIMATION_DURATION.TILE_MOVE);
  }

  // æ£€æŸ¥èƒœåˆ©
  private checkWin(): void {
    if (WinChecker.checkWin(this.tiles)) {
      this.isPlaying = false;
      clearInterval(this.timerInterval);

      GameStorage.saveBestRecord(this.gridSize, this.moveCount, this.timeElapsed);
      GameStorage.clearGameState();
      
      // ğŸ”¥ æ¸…é™¤ AppStorage ä¸­çš„æ¸¸æˆçŠ¶æ€
      AppStorage.delete('currentGameState');
      console.info('[GamePage] ğŸ† æ¸¸æˆå®Œæˆï¼Œå·²æ¸…é™¤çŠ¶æ€');

      this.playWinAnimation();
    }
  }

  // èƒœåˆ©åŠ¨ç”»
  private playWinAnimation(): void {
    SoundService.playWinSound();

    animateTo({
      duration: GameConstants.ANIMATION_DURATION.WIN,
      curve: Curve.EaseInOut
    }, () => {
      this.gridGap = 0;
    });

    setTimeout(() => {
      this.winDialogController = new CustomDialogController({
        builder: WinDialog({
          moveCount: this.moveCount,
          timeElapsed: this.timeElapsed,
          onPlayAgain: () => {
            this.restartGame();
          },
          onBackHome: () => {
            this.goBackHome();
          }
        }),
        autoCancel: false,
        customStyle: true
      });
      this.winDialogController.open();
    }, GameConstants.ANIMATION_DURATION.WIN);
  }

  // é‡æ–°å¼€å§‹
  private restartGame(): void {
    this.moveCount = 0;
    this.timeElapsed = 0;
    this.gridGap = GameConstants.GRID_GAP;
    this.isPeeking = false;
    this.isPlaying = false;
    this.selectedTileIndex = -1;  // æ¸…é™¤é€‰ä¸­çŠ¶æ€
    this.resetDragState();  // æ¸…é™¤æ‹–æ‹½çŠ¶æ€
    
    if (this.timerInterval !== -1) {
      clearInterval(this.timerInterval);
    }

    // ğŸ”¥ æ¸…é™¤æ¸¸æˆçŠ¶æ€ï¼ˆAppStorage + preferencesï¼‰
    AppStorage.delete('currentGameState');
    GameStorage.clearGameState();
    console.info('[GamePage] ğŸ”„ é‡æ–°å¼€å§‹ï¼Œå·²æ¸…é™¤æ—§çŠ¶æ€');

    // é‡æ–°åˆå§‹åŒ–æ¸¸æˆï¼ˆé‡æ–°åˆ‡å‰²å¹¶æ´—ç‰Œï¼Œé‡æ–°ç”ŸæˆisHintï¼‰
    this.initGame();
  }

  // é‡ç½®æ‹–æ‹½çŠ¶æ€
  private resetDragState(): void {
    this.draggedTileIndex = -1;
    this.isDragging = false;
    this.dragOffsetX = 0;
    this.dragOffsetY = 0;
  }

  // æ ¹æ®æ‹–æ‹½åæ ‡è®¡ç®—ç›®æ ‡æ–¹å—ç´¢å¼•
  private calculateDropIndex(absoluteX: number, absoluteY: number): number {
    console.info(`[calculateDropIndex] ========== å¼€å§‹è®¡ç®—ç›®æ ‡ç´¢å¼• ==========`);
    console.info(`[calculateDropIndex] è¾“å…¥åæ ‡: (${absoluteX}, ${absoluteY})`);
    
    // ä¼˜å…ˆä½¿ç”¨åŠ¨æ€è·å–çš„Gridä½ç½®
    let puzzleX = this.gridPositionX;
    let puzzleY = this.gridPositionY;
    let puzzleSize = this.gridActualSize;
    
    // å¦‚æœè¿˜æœªè·å–åˆ°Gridä½ç½®ï¼ˆé¦–æ¬¡æ‹–æ‹½å‰ï¼‰ï¼Œä½¿ç”¨ç¡¬ç¼–ç çš„å¤‡ç”¨å€¼
    if (puzzleSize === 0) {
      console.warn(`[calculateDropIndex] âš ï¸ Gridä½ç½®å°šæœªè·å–ï¼Œä½¿ç”¨ç¡¬ç¼–ç å¤‡ç”¨å€¼`);
      if (this.screenState === ScreenState.TRIPLE) {
        puzzleX = 92;
        puzzleY = 73;
        puzzleSize = 630;
      } else if (this.screenState === ScreenState.DOUBLE) {
        puzzleX = 107;
        puzzleY = 52;
        puzzleSize = 494;
      } else {
        puzzleX = 115;
        puzzleY = 15;
        puzzleSize = 313;
      }
      console.info(`[calculateDropIndex] å¤‡ç”¨å€¼ - å±å¹•çŠ¶æ€: ${this.screenState}`);
    } else {
      console.info(`[calculateDropIndex] âœ… ä½¿ç”¨åŠ¨æ€è·å–çš„Gridä½ç½®`);
    }
    
    console.info(`[calculateDropIndex] GridåŒºåŸŸ: X=${puzzleX}, Y=${puzzleY}, Size=${puzzleSize}`);
    console.info(`[calculateDropIndex] ç½‘æ ¼å°ºå¯¸: ${this.gridSize}Ã—${this.gridSize}`);

    // è®¡ç®—ç›¸å¯¹äºæ‹¼å›¾åŒºåŸŸçš„åæ ‡
    const relativeX = absoluteX - puzzleX;
    const relativeY = absoluteY - puzzleY;
    
    console.info(`[calculateDropIndex] ç›¸å¯¹åæ ‡: (${relativeX}, ${relativeY})`);

    // æ£€æŸ¥æ˜¯å¦åœ¨æ‹¼å›¾åŒºåŸŸå†…
    if (relativeX < 0 || relativeY < 0 || relativeX > puzzleSize || relativeY > puzzleSize) {
      console.warn(`[calculateDropIndex] âŒ åæ ‡è¶…å‡ºæ‹¼å›¾åŒºåŸŸï¼`);
      console.warn(`[calculateDropIndex] æ£€æŸ¥: XèŒƒå›´[0, ${puzzleSize}], å®é™…=${relativeX}`);
      console.warn(`[calculateDropIndex] æ£€æŸ¥: YèŒƒå›´[0, ${puzzleSize}], å®é™…=${relativeY}`);
      return -1;
    }

    // è®¡ç®—æ¯ä¸ªæ–¹å—çš„å°ºå¯¸ï¼ˆåŒ…æ‹¬é—´éš™ï¼‰
    const tileSize = puzzleSize / this.gridSize;
    console.info(`[calculateDropIndex] å•ä¸ªæ–¹å—å°ºå¯¸: ${tileSize}vp`);
    
    // è®¡ç®—è¡Œåˆ—
    const col = Math.floor(relativeX / tileSize);
    const row = Math.floor(relativeY / tileSize);
    
    console.info(`[calculateDropIndex] è®¡ç®—çš„è¡Œåˆ—: row=${row}, col=${col}`);
    
    // ç¡®ä¿åœ¨æœ‰æ•ˆèŒƒå›´å†…
    if (col >= this.gridSize || row >= this.gridSize) {
      console.warn(`[calculateDropIndex] âŒ è¡Œåˆ—è¶…å‡ºèŒƒå›´ï¼`);
      return -1;
    }

    const index = row * this.gridSize + col;
    console.info(`[calculateDropIndex] âœ… è®¡ç®—å‡ºçš„ç´¢å¼•: ${index}`);
    console.info(`[calculateDropIndex] ========== è®¡ç®—å®Œæˆ ==========`);
    return index;
  }

  // åˆ‡æ¢æ¨¡å¼
  private async toggleMode(): Promise<void> {
    this.gameMode = this.gameMode === GameConstants.GAME_MODE.HUARONG ? 
      GameConstants.GAME_MODE.SWAP : GameConstants.GAME_MODE.HUARONG;
    
    // åœæ­¢å½“å‰æ¸¸æˆ
    this.isPlaying = false;
    if (this.timerInterval !== -1) {
    clearInterval(this.timerInterval);
    }

    // é‡æ–°åˆå§‹åŒ–æ¸¸æˆ
    this.moveCount = 0;
    this.timeElapsed = 0;
    this.gridGap = GameConstants.GRID_GAP;
    this.isPeeking = false;

    // é‡æ–°åˆ‡å‰²å¹¶æ´—ç‰Œ
    if (this.originalPixelMap) {
      try {
        const createEmpty = (this.gameMode === GameConstants.GAME_MODE.HUARONG);
        const tilesData = await ImageSlicer.sliceImage(this.originalPixelMap, this.gridSize, createEmpty);
        this.tiles = tilesData;
        this.emptyIndex = this.gridSize * this.gridSize - 1;

        // å»¶è¿Ÿåæ´—ç‰Œ
        setTimeout(() => {
          this.shuffleWithAnimation();
        }, 500);
      } catch (error) {
        console.error('é‡æ–°åˆ‡å‰²å›¾ç‰‡å¤±è´¥:', error);
      }
    }
  }

  // åˆ‡æ¢éš¾åº¦
  private changeDifficulty(newDifficulty: number): void {
    if (newDifficulty !== this.gridSize) {
      this.gridSize = newDifficulty;
      this.initGame();
    }
  }

  // å·çœ‹ç­”æ¡ˆ
  private togglePeek(): void {
    if (!this.isPeeking) {
      // å¼€å§‹å·çœ‹ - ä¿å­˜å½“å‰æ‰“ä¹±çš„çŠ¶æ€
      this.isPeeking = true;
      
      console.info('[GamePage] å·çœ‹ç­”æ¡ˆ - ä¿å­˜å½“å‰çŠ¶æ€');
      
      // æ·±æ‹·è´ä¿å­˜å½“å‰çš„tilesçŠ¶æ€ï¼ˆåŒ…æ‹¬æ‰“ä¹±çš„é¡ºåºå’ŒisHintçŠ¶æ€ï¼‰
      this.savedTilesBeforePeek = this.tiles.map(tile => 
        new TileData(tile.id, tile.currentIndex, tile.pixelMap, tile.isEmpty, tile.isHint)
      );
      
      // ä¿å­˜ç©ºæ ¼ä½ç½®
      this.savedEmptyIndexBeforePeek = this.emptyIndex;
      
      console.info(`[GamePage] å·²ä¿å­˜ ${this.savedTilesBeforePeek.length} ä¸ªæ–¹å—çš„çŠ¶æ€`);
      
      // æš‚åœæ¸¸æˆ
      this.isPlaying = false;

      // æ˜¾ç¤ºç­”æ¡ˆ
    animateTo({
      duration: GameConstants.ANIMATION_DURATION.TILE_MOVE,
      curve: Curve.EaseOut
    }, () => {
      this.tiles = WinChecker.restoreAnswer(this.tiles);
      this.emptyIndex = this.gridSize * this.gridSize - 1;
      this.gridGap = 0;
    });
    } else {
      // å›å½’ä½œç­” - æ¢å¤ä¹‹å‰ä¿å­˜çš„æ‰“ä¹±çŠ¶æ€
      this.isPeeking = false;
      
      console.info('[GamePage] å›å½’ä½œç­” - æ¢å¤ä¹‹å‰çš„æ‰“ä¹±çŠ¶æ€');
      
      animateTo({
        duration: GameConstants.ANIMATION_DURATION.TILE_MOVE,
        curve: Curve.EaseOut
      }, () => {
        // æ¢å¤ä¿å­˜çš„tilesæ‰“ä¹±çŠ¶æ€ï¼ˆåŒ…æ‹¬isHintçŠ¶æ€ï¼‰
        if (this.savedTilesBeforePeek.length > 0) {
          this.tiles = this.savedTilesBeforePeek.map(tile => 
            new TileData(tile.id, tile.currentIndex, tile.pixelMap, tile.isEmpty, tile.isHint)
          );
          
          // æ¢å¤ç©ºæ ¼ä½ç½®
          this.emptyIndex = this.savedEmptyIndexBeforePeek;
          
          console.info(`[GamePage] å·²æ¢å¤ ${this.tiles.length} ä¸ªæ–¹å—çš„æ‰“ä¹±çŠ¶æ€`);
        } else {
          console.warn('[GamePage] è­¦å‘Šï¼šæ²¡æœ‰ä¿å­˜çš„çŠ¶æ€å¯æ¢å¤');
        }
        
        // æ¢å¤é—´éš™
        this.gridGap = GameConstants.GRID_GAP;
      });
      
      // æ¢å¤æ¸¸æˆ
      this.isPlaying = true;
    }
  }

  // è¿”å›ä¸Šä¸€çº§é¡µé¢
  private goBackHome(): void {
    router.back();
  }

  // æ ¼å¼åŒ–æ—¶é—´
  private formatTime(seconds: number): string {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  }

  // æ‹¼å›¾åŒºåŸŸï¼ˆè¾…åŠ©Builderï¼Œæ¥å—å°ºå¯¸å’Œä½ç½®å‚æ•°ï¼‰
  @Builder
  puzzleAreaBuilder(width: number, height: number, x: number, y: number) {
    Stack() {
      // æ‹¼å›¾ç½‘æ ¼
      Grid() {
        ForEach(this.tiles, (tile: TileData, index: number) => {
          GridItem() {
            if (tile.isEmpty) {
              // ç©ºæ ¼
              Column()
                .width('100%')
                .height('100%')
                .backgroundColor(GameConstants.COLORS.EMPTY_BG)
            } else {
              // æ–¹å—
              Stack() {
                // æ–¹å—å›¾ç‰‡
                if (tile.pixelMap) {
                  Image(tile.pixelMap)
                    .width('100%')
                    .height('100%')
                    .objectFit(ImageFit.Fill)
                    .draggable(false)  // ç¦ç”¨ç³»ç»Ÿæ‹–æ‹½ï¼Œé¿å…æ‹¦æˆªPanGesture
                }

                // åå®¹é“æ¨¡å¼ï¼šæ•°å­—æ ‡è®°
                if (this.gameMode === GameConstants.GAME_MODE.HUARONG) {
                  Text(`${tile.id + 1}`)
                    .fontSize(24)
                    .fontWeight(FontWeight.Bold)
                    .fontColor('#FFFFFF')
                    .textShadow({ radius: 4, color: '#000000', offsetX: 0, offsetY: 0 })
                    .backgroundColor('rgba(0, 0, 0, 0.6)')
                    .padding({ left: 8, right: 8, top: 4, bottom: 4 })
                    .borderRadius(8)
                    .position({ x: 8, y: 8 })
                }

                // äº¤æ¢æ¨¡å¼ï¼šæç¤ºæ–¹å—é®ç½©ï¼ˆé»‘è‰²é˜´å½±ï¼Œæ— æè¾¹ï¼‰
                if (this.gameMode === GameConstants.GAME_MODE.SWAP && tile.isHint) {
                  Column()
                    .width('100%')
                    .height('100%')
                    .backgroundColor('rgba(0, 0, 0, 0.55)')
                }

                // äº¤æ¢æ¨¡å¼ï¼šé€‰ä¸­çŠ¶æ€æŒ‡ç¤º
                if (this.gameMode === GameConstants.GAME_MODE.SWAP && this.selectedTileIndex === index) {
                  Column()
                    .width('100%')
                    .height('100%')
                    .backgroundColor('rgba(24, 144, 255, 0.3)')
                    .border({ width: 3, color: '#24FF00' })
                }

                // æ‹–æ‹½ä¸­çš„è§†è§‰æ•ˆæœ
                if (this.isDragging && this.draggedTileIndex === index) {
                  Column()
                    .width('100%')
                    .height('100%')
                    .backgroundColor('rgba(255, 255, 255, 0.5)')
                }
              }
              .width('100%')
              .height('100%')
              .backgroundColor(GameConstants.COLORS.TILE_BG)
              .opacity(this.isDragging && this.draggedTileIndex === index ? 0.3 : 1)  // æ‹–æ‹½æ—¶åŸä½ç½®åŠé€æ˜å ä½
              .onClick(() => {
                this.onTileClick(index);
              })
              // äº¤æ¢æ¨¡å¼ï¼šæ·»åŠ æ‹–æ‹½æ‰‹åŠ¿æ”¯æŒï¼ˆä½¿ç”¨PanGestureï¼Œparallelæ¨¡å¼ä¸ç‚¹å‡»å…±å­˜ï¼‰
              .parallelGesture(
                PanGesture({ distance: 5, fingers: 1 })
                  .onActionStart((event: GestureEvent) => {
                    // åªåœ¨äº¤æ¢æ¨¡å¼ä¸”éæç¤ºæ–¹å—æ—¶å“åº”
                    if (this.isPlaying && this.gameMode === GameConstants.GAME_MODE.SWAP && !tile.isHint) {
                      console.info(`[GamePage] ========== å¼€å§‹æ‹–æ‹½æ–¹å— ${index} ==========`);
                      this.draggedTileIndex = index;
                      this.isDragging = true;
                      // è®°å½•èµ·å§‹ä½ç½®ï¼ˆå…¨å±€åæ ‡ï¼‰
                      this.dragStartX = event.fingerList[0].globalX;
                      this.dragStartY = event.fingerList[0].globalY;
                      console.info(`[GamePage] èµ·å§‹åæ ‡: globalX=${this.dragStartX}, globalY=${this.dragStartY}`);
                      console.info(`[GamePage] èµ·å§‹åæ ‡: localX=${event.fingerList[0].localX}, localY=${event.fingerList[0].localY}`);
                    }
                  })
                  .onActionUpdate((event: GestureEvent) => {
                    // åªåœ¨æ‹–æ‹½çŠ¶æ€ä¸‹æ›´æ–°åç§»é‡
                    if (this.isDragging && this.gameMode === GameConstants.GAME_MODE.SWAP) {
                      // æ›´æ–°æ‹–æ‹½åç§»é‡
                      this.dragOffsetX = event.offsetX;
                      this.dragOffsetY = event.offsetY;
                      // å®æ—¶è¾“å‡ºåæ ‡ï¼ˆç”¨äºè°ƒè¯•ï¼‰
                      if (Math.abs(this.dragOffsetX) > 10 || Math.abs(this.dragOffsetY) > 10) {
                        const currentX = this.dragStartX + this.dragOffsetX;
                        const currentY = this.dragStartY + this.dragOffsetY;
                        console.debug(`[GamePage] æ‹–æ‹½ä¸­: offset=(${event.offsetX}, ${event.offsetY}), current=(${currentX}, ${currentY})`);
                      }
                    }
                  })
                  .onActionEnd((event: GestureEvent) => {
                    // å¤„ç†æ‹–æ‹½ç»“æŸ
                    if (this.isDragging && this.gameMode === GameConstants.GAME_MODE.SWAP) {
                      // ä½¿ç”¨æœ€ç»ˆçš„globalX/globalYè€Œä¸æ˜¯èµ·å§‹+åç§»
                      const endX = event.fingerList[0].globalX;
                      const endY = event.fingerList[0].globalY;
                      
                      console.info(`[GamePage] ========== æ‹–æ‹½ç»“æŸ ==========`);
                      console.info(`[GamePage] ç»“æŸåæ ‡: globalX=${endX}, globalY=${endY}`);
                      console.info(`[GamePage] ç»“æŸåæ ‡: localX=${event.fingerList[0].localX}, localY=${event.fingerList[0].localY}`);
                      console.info(`[GamePage] æ€»åç§»: offsetX=${event.offsetX}, offsetY=${event.offsetY}`);
                      console.info(`[GamePage] å±å¹•çŠ¶æ€: ${this.screenState}, å®é™…å°ºå¯¸: ${this.actualWidth}Ã—${this.actualHeight}`);
                      
                      // è®¡ç®—ç›®æ ‡æ–¹å—ç´¢å¼•
                      const targetIndex = this.calculateDropIndex(endX, endY);
                      
                      console.info(`[GamePage] è®¡ç®—ç»“æœ: ç›®æ ‡ç´¢å¼•=${targetIndex}, èµ·å§‹ç´¢å¼•=${this.draggedTileIndex}`);
                      
                      if (targetIndex !== -1 && targetIndex !== this.draggedTileIndex && 
                          !this.tiles[targetIndex].isHint) {
                        console.info(`[GamePage] âœ… æ‰§è¡Œäº¤æ¢: ${this.draggedTileIndex} <-> ${targetIndex}`);
                        this.swapTiles(this.draggedTileIndex, targetIndex);
                      } else {
                        if (targetIndex === -1) {
                          console.warn(`[GamePage] âŒ æ‹–æ‹½å–æ¶ˆ: åæ ‡ä¸åœ¨æœ‰æ•ˆåŒºåŸŸå†…`);
                        } else if (targetIndex === this.draggedTileIndex) {
                          console.warn(`[GamePage] âŒ æ‹–æ‹½å–æ¶ˆ: æœªç§»åŠ¨åˆ°å…¶ä»–æ–¹å—`);
                        } else if (this.tiles[targetIndex].isHint) {
                          console.warn(`[GamePage] âŒ æ‹–æ‹½å–æ¶ˆ: ç›®æ ‡æ˜¯å›ºå®šæç¤ºæ–¹å—`);
                        }
                      }
                      
                      // æ¸…é™¤æ‹–æ‹½çŠ¶æ€
                      this.resetDragState();
                      console.info(`[GamePage] ========== æ‹–æ‹½æµç¨‹ç»“æŸ ==========`);
                    } else if (this.isDragging) {
                      // å¦‚æœåœ¨å…¶ä»–æ¨¡å¼ä¸‹è¯¯è§¦å‘äº†æ‹–æ‹½ï¼Œé‡ç½®çŠ¶æ€
                      console.warn(`[GamePage] âš ï¸ éäº¤æ¢æ¨¡å¼ï¼Œé‡ç½®æ‹–æ‹½çŠ¶æ€`);
                      this.resetDragState();
                    }
                  })
              )
            }
          }
        })
      }
      .columnsTemplate('1fr '.repeat(this.gridSize).trim())
      .rowsTemplate('1fr '.repeat(this.gridSize).trim())
      .columnsGap(this.gridGap)
      .rowsGap(this.gridGap)
      .width('100%')
      .height('100%')
      .backgroundColor('#FFFFFF')
      .clip(true)
      .onAreaChange((oldValue: Area, newValue: Area) => {
        // åŠ¨æ€è·å–Gridç»„ä»¶çš„å®é™…ä½ç½®å’Œå°ºå¯¸
        if (newValue.position && newValue.globalPosition && newValue.width) {
          this.gridPositionX = Number(newValue.globalPosition.x ?? 0);
          this.gridPositionY = Number(newValue.globalPosition.y ?? 0);
          this.gridActualSize = Number(newValue.width ?? 0);
          console.info(`[GamePage] Gridä½ç½®æ›´æ–°: X=${this.gridPositionX}, Y=${this.gridPositionY}, Size=${this.gridActualSize}`);
        }
      })
    }
    .width(width)
    .height(height)
    .borderRadius(25)
    .shadow({ 
      radius: 25,
      color: 'rgba(0, 0, 0, 0.25)',
      offsetX: 4,
      offsetY: 4
    })
    .position({ x: x, y: y })
  }

  // ä¸‰å±å¸ƒå±€ï¼ˆæ‰€æœ‰å‚æ•°å†™æ­»ï¼‰
  @Builder
  buildTripleLayout() {
    Stack() {
      // èƒŒæ™¯å›¾ç‰‡
      Image($rawfile('images/å…¶ä½™é¡µé¢èƒŒæ™¯å›¾.png'))
        .width('100%')
        .height('100%')
        .objectFit(ImageFit.Cover)

      // æ‹¼å›¾åŒºåŸŸï¼ˆå†™æ­»ï¼‰
      this.puzzleAreaBuilder(630, 630, 92, 73)

      // è¿”å›æŒ‰é’®ï¼ˆå†™æ­»ï¼‰
      Button() {
        Image($rawfile('images/icon/è¿”å›.png'))
          .width(37)
          .height(35)
      }
      .width(60)
      .height(60)
      .backgroundColor('rgba(255, 255, 255, 0.9)')
      .borderRadius(30)
      .position({ x: 20, y: 21 })
      .onClick(() => {
        this.goBackHome();
      })

      // ä¸»é¡µæŒ‰é’®ï¼ˆå†™æ­»ï¼‰
      Button() {
        Image($rawfile('images/icon/ä¸»é¢˜.png'))
          .width(32)
          .height(32)
      }
      .width(60)
      .height(60)
      .backgroundColor('rgba(255, 255, 255, 0.9)')
      .borderRadius(30)
      .position({ x: 90, y: 21 })
      .onClick(() => {
        router.pushUrl({
          url: 'pages/ThemeSelectionPage'
        }).catch((err: Error) => {
          console.error('è·³è½¬å¤±è´¥:', err);
        });
      })

      // å£°éŸ³æ§åˆ¶æŒ‰é’®ï¼ˆå³ä¸Šè§’ï¼‰
      SoundButton({ buttonSize: 60, iconSize: 32 })
        .position({ x: 1020, y: 21 })

      // åˆ‡æ¢æ¨¡å¼æŒ‰é’®ï¼ˆå†™æ­»ï¼‰
      Button() {
        Text(this.gameMode === GameConstants.GAME_MODE.HUARONG ? 'åå®¹é“æ¨¡å¼' : 'äº¤æ¢æ¨¡å¼')
          .fontFamily('Muyao-Softbrush')
          .fontSize(48)
          .fontColor('#000000')
      }
      .width(287)
      .height(74)
      .backgroundColor('rgba(255, 255, 255, 0.91)')
      .borderRadius(25)
      .border({ width: 4, color: Color.Transparent })
      .position({ x: 769, y: 148 })
      .onClick(() => {
        this.toggleMode();
      })

      // åˆ‡æ¢éš¾åº¦æŒ‰é’®ï¼ˆå†™æ­»ï¼‰
      Button() {
        Text(`éš¾åº¦ ${this.gridSize} Ã— ${this.gridSize}`)
          .fontFamily('Muyao-Softbrush')
          .fontSize(48)
          .fontColor('#000000')
      }
      .width(306)
      .height(74)
      .backgroundColor('rgba(255, 255, 255, 0.91)')
      .borderRadius(25)
      .border({ width: 4, color: Color.Transparent })
      .position({ x: 767, y: 283 })
      .onClick(() => {
        this.difficultyDialogController = new CustomDialogController({
          builder: DifficultyDialog({
            selectedDifficulty: this.gridSize,
            onDifficultySelected: (difficulty: number) => {
              this.changeDifficulty(difficulty);
            }
          }),
          autoCancel: true,
          customStyle: true
        });
        this.difficultyDialogController.open();
      })

      // å·çœ‹ç­”æ¡ˆ/å›å½’ä½œç­”æŒ‰é’®ï¼ˆå†™æ­»ï¼‰
      Button() {
        Text(this.isPeeking ? 'å›å½’ä½œç­”' : 'å·çœ‹ç­”æ¡ˆ')
          .fontFamily('Muyao-Softbrush')
          .fontSize(48)
          .fontColor('#000000')
      }
      .width(254)
      .height(74)
      .backgroundColor('rgba(255, 255, 255, 0.91)')
      .borderRadius(25)
      .border({ width: 4, color: Color.Transparent })
      .position({ x: 793, y: 418 })
      .onClick(() => {
        this.togglePeek();
      })

      // é‡æ–°å¼€å§‹æŒ‰é’®ï¼ˆå†™æ­»ï¼‰
      Button() {
        Text('é‡æ–°å¼€å§‹')
          .fontFamily('Muyao-Softbrush')
          .fontSize(48)
          .fontColor('#000000')
      }
      .width(254)
      .height(74)
      .backgroundColor('rgba(255, 255, 255, 0.91)')
      .borderRadius(25)
      .border({ width: 4, color: Color.Transparent })
      .position({ x: 793, y: 553 })
      .onClick(() => {
        this.restartGame();
      })
    }
    .width(1107)
    .height(776)
  }

  // åŒå±å¸ƒå±€ï¼ˆæ‰€æœ‰å‚æ•°å†™æ­»ï¼‰
  @Builder
  buildDoubleLayout() {
    Stack() {
      // èƒŒæ™¯å›¾ç‰‡
      Image($rawfile('images/å…¶ä½™é¡µé¢èƒŒæ™¯å›¾.png'))
        .width('100%')
        .height('100%')
        .objectFit(ImageFit.Cover)

      // æ‹¼å›¾åŒºåŸŸï¼ˆå†™æ­»ï¼‰
      this.puzzleAreaBuilder(494, 475, 107, 52)

      // è¿”å›æŒ‰é’®ï¼ˆå†™æ­»ï¼‰
      Button() {
        Image($rawfile('images/icon/è¿”å›.png'))
          .width(37)
          .height(35)
      }
      .width(60)
      .height(60)
      .backgroundColor('rgba(255, 255, 255, 0.9)')
      .borderRadius(30)
      .position({ x: 17, y: 22 })
      .onClick(() => {
        this.goBackHome();
      })

      // ä¸»é¡µæŒ‰é’®ï¼ˆå†™æ­»ï¼‰
      Button() {
        Image($rawfile('images/icon/ä¸»é¢˜.png'))
          .width(32)
          .height(32)
      }
      .width(60)
      .height(60)
      .backgroundColor('rgba(255, 255, 255, 0.9)')
      .borderRadius(30)
      .position({ x: 87, y: 22 })
      .onClick(() => {
        router.pushUrl({
          url: 'pages/ThemeSelectionPage'
        }).catch((err: Error) => {
          console.error('è·³è½¬å¤±è´¥:', err);
        });
      })

      // å£°éŸ³æ§åˆ¶æŒ‰é’®ï¼ˆå³ä¸Šè§’ï¼‰
      SoundButton({ buttonSize: 60, iconSize: 32 })
        .position({ x: 625, y: 22 })

      // åˆ‡æ¢æ¨¡å¼æŒ‰é’®ï¼ˆå†™æ­»ï¼‰
      Button() {
        Text(this.gameMode === GameConstants.GAME_MODE.HUARONG ? 'åå®¹é“æ¨¡å¼' : 'äº¤æ¢æ¨¡å¼')
          .fontFamily('Muyao-Softbrush')
          .fontSize(48)
          .fontColor('#000000')
      }
      .width(287)
      .height(74)
      .backgroundColor('rgba(255, 255, 255, 1)')
      .borderRadius(25)
      .border({ width: 4, color: Color.Transparent })
      .position({ x: 54, y: 556 })
      .onClick(() => {
        this.toggleMode();
      })

      // åˆ‡æ¢éš¾åº¦æŒ‰é’®ï¼ˆå†™æ­»ï¼‰
      Button() {
        Text(`éš¾åº¦ ${this.gridSize} Ã— ${this.gridSize}`)
          .fontFamily('Muyao-Softbrush')
          .fontSize(48)
          .fontColor('#000000')
      }
      .width(287)
      .height(74)
      .backgroundColor('rgba(255, 255, 255, 1)')
      .borderRadius(25)
      .border({ width: 4, color: Color.Transparent })
      .position({ x: 372, y: 556 })
      .onClick(() => {
        this.difficultyDialogController = new CustomDialogController({
          builder: DifficultyDialog({
            selectedDifficulty: this.gridSize,
            onDifficultySelected: (difficulty: number) => {
              this.changeDifficulty(difficulty);
            }
          }),
          autoCancel: true,
          customStyle: true
        });
        this.difficultyDialogController.open();
      })

      // å·çœ‹ç­”æ¡ˆ/å›å½’ä½œç­”æŒ‰é’®ï¼ˆå†™æ­»ï¼‰
      Button() {
        Text(this.isPeeking ? 'å›å½’ä½œç­”' : 'å·çœ‹ç­”æ¡ˆ')
          .fontFamily('Muyao-Softbrush')
          .fontSize(48)
          .fontColor('#000000')
      }
      .width(254)
      .height(74)
      .backgroundColor('rgba(255, 255, 255, 1)')
      .borderRadius(25)
      .border({ width: 4, color: Color.Transparent })
      .position({ x: 70, y: 661 })
      .onClick(() => {
        this.togglePeek();
      })

      // é‡æ–°å¼€å§‹æŒ‰é’®ï¼ˆå†™æ­»ï¼‰
      Button() {
        Text('é‡æ–°å¼€å§‹')
          .fontFamily('Muyao-Softbrush')
          .fontSize(48)
          .fontColor('#000000')
      }
      .width(254)
      .height(74)
      .backgroundColor('rgba(255, 255, 255, 1)')
      .borderRadius(25)
      .border({ width: 4, color: Color.Transparent })
      .position({ x: 388, y: 661 })
      .onClick(() => {
        this.restartGame();
      })
    }
    .width(712)
    .height(776)
  }

  // å•å±å¸ƒå±€ï¼ˆæ‰€æœ‰å‚æ•°å†™æ­»ï¼‰
  @Builder
  buildSingleLayout() {
    Stack() {
      // èƒŒæ™¯å›¾ç‰‡
      Image($rawfile('images/å…¶ä½™é¡µé¢èƒŒæ™¯å›¾.png'))
        .width('100%')
        .height('100%')
        .objectFit(ImageFit.Cover)

      // æ‹¼å›¾åŒºåŸŸï¼ˆå†™æ­»ï¼‰
      this.puzzleAreaBuilder(313, 320, 115, 15)

      // è¿”å›æŒ‰é’®ï¼ˆå†™æ­» - æ³¨æ„å•å±ä¸‹å°ºå¯¸ä¸åŒï¼‰
      Button() {
        Image($rawfile('images/icon/è¿”å›.png'))
          .width(20)
          .height(17)
      }
      .width(35)
      .height(35)
      .backgroundColor('rgba(255, 255, 255, 0.9)')
      .borderRadius(17.5)
      .position({ x: 18, y: 11 })
      .onClick(() => {
        this.goBackHome();
      })

      // ä¸»é¡µæŒ‰é’®ï¼ˆå†™æ­»ï¼‰
      Button() {
        Image($rawfile('images/icon/ä¸»é¢˜.png'))
          .width(20)
          .height(20)
      }
      .width(35)
      .height(35)
      .backgroundColor('rgba(255, 255, 255, 0.9)')
      .borderRadius(17.5)
      .position({ x: 63, y: 11 })
      .onClick(() => {
        router.pushUrl({
          url: 'pages/ThemeSelectionPage'
        }).catch((err: Error) => {
          console.error('è·³è½¬å¤±è´¥:', err);
        });
      })

      // å£°éŸ³æ§åˆ¶æŒ‰é’®ï¼ˆå³ä¸Šè§’ï¼‰
      SoundButton({ buttonSize: 35, iconSize: 20 })
        .position({ x: 723, y: 11 })

      // åˆ‡æ¢æ¨¡å¼æŒ‰é’®ï¼ˆå†™æ­»ï¼‰
      Button() {
        Text(this.gameMode === GameConstants.GAME_MODE.HUARONG ? 'åå®¹é“æ¨¡å¼' : 'äº¤æ¢æ¨¡å¼')
          .fontFamily('Muyao-Softbrush')
          .fontSize(35)
          .fontColor('#000000')
      }
      .width(206)
      .height(65)
      .backgroundColor('rgba(255, 255, 255, 1)')
      .borderRadius(25)
      .border({ width: 4, color: Color.Transparent })
      .position({ x: 503, y: 24 })
      .onClick(() => {
        this.toggleMode();
      })

      // åˆ‡æ¢éš¾åº¦æŒ‰é’®ï¼ˆå†™æ­»ï¼‰
      Button() {
        Text(`éš¾åº¦ ${this.gridSize} Ã— ${this.gridSize}`)
          .fontFamily('Muyao-Softbrush')
          .fontSize(35)
          .fontColor('#000000')
      }
      .width(206)
      .height(65)
      .backgroundColor('rgba(255, 255, 255, 1)')
      .borderRadius(25)
      .border({ width: 4, color: Color.Transparent })
      .position({ x: 503, y: 103 })
      .onClick(() => {
        this.difficultyDialogController = new CustomDialogController({
          builder: DifficultyDialog({
            selectedDifficulty: this.gridSize,
            onDifficultySelected: (difficulty: number) => {
              this.changeDifficulty(difficulty);
            }
          }),
          autoCancel: true,
          customStyle: true
        });
        this.difficultyDialogController.open();
      })

      // å·çœ‹ç­”æ¡ˆ/å›å½’ä½œç­”æŒ‰é’®ï¼ˆå†™æ­»ï¼‰
      Button() {
        Text(this.isPeeking ? 'å›å½’ä½œç­”' : 'å·çœ‹ç­”æ¡ˆ')
          .fontFamily('Muyao-Softbrush')
          .fontSize(35)
          .fontColor('#000000')
      }
      .width(190)
      .height(65)
      .backgroundColor('rgba(255, 255, 255, 1)')
      .borderRadius(25)
      .border({ width: 4, color: Color.Transparent })
      .position({ x: 511, y: 182 })
      .onClick(() => {
        this.togglePeek();
      })

      // é‡æ–°å¼€å§‹æŒ‰é’®ï¼ˆå†™æ­»ï¼‰
      Button() {
        Text('é‡æ–°å¼€å§‹')
          .fontFamily('Muyao-Softbrush')
          .fontSize(35)
          .fontColor('#000000')
      }
      .width(190)
      .height(65)
      .backgroundColor('rgba(255, 255, 255, 1)')
      .borderRadius(25)
      .border({ width: 4, color: Color.Transparent })
      .position({ x: 511, y: 261 })
      .onClick(() => {
        this.restartGame();
      })
    }
    .width(776)
    .height(350)
  }

  // æ‹–æ‹½æµ®å±‚ï¼šæ˜¾ç¤ºåœ¨æ•´ä¸ªå±å¹•æœ€é¡¶å±‚
  @Builder
  buildDraggingOverlay() {
    if (this.draggedTileIndex >= 0 && this.draggedTileIndex < this.tiles.length) {
      Stack() {
        // æ˜¾ç¤ºè¢«æ‹–æ‹½çš„åˆ‡ç‰‡
        if (this.tiles[this.draggedTileIndex].pixelMap) {
          Image(this.tiles[this.draggedTileIndex].pixelMap)
            .width('100%')
            .height('100%')
            .objectFit(ImageFit.Fill)
        }
        
        // åŠé€æ˜ç™½è‰²é®ç½©
        Column()
          .width('100%')
          .height('100%')
          .backgroundColor('rgba(255, 255, 255, 0.3)')
      }
      .width(this.gridActualSize / this.gridSize)
      .height(this.gridActualSize / this.gridSize)
      .backgroundColor(GameConstants.COLORS.TILE_BG)
      .borderRadius(8)
      .opacity(0.85)
      .scale({ x: 1.1, y: 1.1 })
      .shadow({ 
        radius: 20,
        color: 'rgba(0, 0, 0, 0.5)',
        offsetX: 4,
        offsetY: 4
      })
      .position({ 
        x: (this.dragStartX + this.dragOffsetX) - (this.gridActualSize / this.gridSize) / 2,
        y: (this.dragStartY + this.dragOffsetY) - (this.gridActualSize / this.gridSize) / 2
      })
      .zIndex(9999)
    }
  }

  /**
   * ğŸ”¥ æ¸…é™¤æ¸¸æˆçŠ¶æ€åç«‹å³æ›´æ–°æ‰€æœ‰å¡ç‰‡
   */
  private async updateAllFormsAfterClear(): Promise<void> {
    try {
      console.info('[GamePage] ğŸ”„ å¼€å§‹æ›´æ–°æ‰€æœ‰å¡ç‰‡ï¼ˆæ˜¾ç¤º"å¼€å§‹æ–°æ¸¸æˆ"ï¼‰');
      
      // è·å–åº”ç”¨ä¸Šä¸‹æ–‡
      const context = getContext(this) as common.UIAbilityContext;
      
      // è¯»å–æ‰€æœ‰å¡ç‰‡ID
      const dataPreferences: preferences.Preferences = await preferences.getPreferences(context, 'formIds');
      const formIdsStr: string = await dataPreferences.get('ids', '[]') as string;
      const formIds: Array<string> = JSON.parse(formIdsStr);
      
      console.info('[GamePage] ğŸ“‹ è¯»å–åˆ° %{public}d ä¸ªå¡ç‰‡', formIds.length);
      
      if (formIds.length === 0) {
        console.warn('[GamePage] âš ï¸ æ²¡æœ‰å·²æ·»åŠ çš„å¡ç‰‡ï¼Œè·³è¿‡æ›´æ–°');
        return;
      }
      
      // ğŸ”¥ åˆ›å»º"å¼€å§‹æ–°æ¸¸æˆ"çš„å¡ç‰‡æ•°æ®
      const formData: FormDataContent = {
        title: 'æ‹¼å›¾æ¸¸æˆ',
        gameMode: 'äº¤æ¢æ¨¡å¼',
        gridSize: '3Ã—3',
        moveCount: 0,
        timeElapsed: '00:00',
        hasActiveGame: false
      };
      
      // ğŸ”¥ æ›´æ–°æ‰€æœ‰å¡ç‰‡
      for (const formId of formIds) {
        try {
          await formProvider.updateForm(formId, formBindingData.createFormBindingData(formData));
          console.info('[GamePage] âœ… å¡ç‰‡ %{public}s æ›´æ–°æˆåŠŸ', formId);
        } catch (error) {
          const err = error as Error;
          console.error('[GamePage] âŒ å¡ç‰‡ %{public}s æ›´æ–°å¤±è´¥: %{public}s', formId, err.message);
        }
      }
      
      console.info('[GamePage] âœ… æ‰€æœ‰å¡ç‰‡æ›´æ–°å®Œæˆ');
    } catch (error) {
      const err = error as Error;
      console.error('[GamePage] âŒ æ›´æ–°å¡ç‰‡è¿‡ç¨‹å‡ºé”™: %{public}s', err.message);
    }
  }

  build() {
    Stack() {
      // åŸæœ‰æ¸¸æˆå¸ƒå±€
      Column() {
        if (this.screenState === ScreenState.TRIPLE) {
          this.buildTripleLayout()
        } else if (this.screenState === ScreenState.DOUBLE) {
          this.buildDoubleLayout()
        } else {
          this.buildSingleLayout()
        }
      }
      .width('100%')
      .height('100%')
      .justifyContent(FlexAlign.Center)
      
      // æ‹–æ‹½æµ®å±‚ï¼šè¦†ç›–æ•´ä¸ªå±å¹•ï¼Œæ˜¾ç¤ºåœ¨æœ€é¡¶å±‚
      if (this.isDragging) {
        this.buildDraggingOverlay()
      }
    }
    .width('100%')
    .height('100%')
  }
}
