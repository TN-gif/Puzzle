import { router } from '@kit.ArkUI';
import { image } from '@kit.ImageKit';
import { TileData } from '../models/TileData';
import { ImageSlicer } from '../utils/ImageSlicer';
import { ShuffleHelper } from '../utils/ShuffleHelper';
import { WinChecker } from '../utils/WinChecker';
import { UriConverter } from '../utils/UriConverter';
import { SoundService } from '../utils/SoundService';
import { GameStorage } from '../utils/GameStorage';
import { GameConstants } from '../constants/GameConstants';
import { WinDialog } from '../components/WinDialog';
import { mediaquery } from '@kit.ArkUI';

/**
 * è·¯ç”±å‚æ•°æ¥å£
 */
interface GamePageParams {
  gameMode: string;
  gridSize: number;
  imageResource: Resource | string;
  isCustomImage: boolean;
  isNetworkImage: boolean;
}

/**
 * æ¸¸æˆé¡µï¼šæ‹¼å›¾æ¸¸æˆæ ¸å¿ƒé€»è¾‘
 */
@Entry
@Component
struct GamePage {
  // è·¯ç”±å‚æ•°
  @State gameMode: string = GameConstants.GAME_MODE.SWAP;
  @State gridSize: number = 3;
  @State imageResource: Resource | string = '';
  @State isCustomImage: boolean = false;
  @State isNetworkImage: boolean = false;

  // æ¸¸æˆçŠ¶æ€
  @State tiles: TileData[] = [];
  @State emptyIndex: number = 8;
  @State moveCount: number = 0;
  @State timeElapsed: number = 0;
  @State isPlaying: boolean = false;
  @State originalPixelMap: image.PixelMap | null = null;

  // UIçŠ¶æ€
  @State isPeeking: boolean = false;
  @State gridGap: number = GameConstants.GRID_GAP;
  @State isWideScreen: boolean = false;
  @State draggedTileIndex: number = -1;  // æ‹–æ‹½çš„æ–¹å—ç´¢å¼•
  @State selectedTileIndex: number = -1; // äº¤æ¢æ¨¡å¼ä¸‹é€‰ä¸­çš„æ–¹å—

  // å®šæ—¶å™¨
  private timerInterval: number = -1;
  private listener: mediaquery.MediaQueryListener | null = null;

  // èƒœåˆ©å¯¹è¯æ¡†
  private winDialogController: CustomDialogController = new CustomDialogController({
    builder: WinDialog({
      moveCount: this.moveCount,
      timeElapsed: this.timeElapsed,
      onPlayAgain: () => {
        this.restartGame();
      },
      onBackHome: () => {
        this.goBackHome();
      }
    }),
    autoCancel: false,
    customStyle: true
  });

  async aboutToAppear() {
    // è·å–è·¯ç”±å‚æ•°
    const params = router.getParams() as GamePageParams;

    if (params) {
      this.gameMode = params.gameMode || GameConstants.GAME_MODE.SWAP;
      this.gridSize = params.gridSize || 3;
      this.imageResource = params.imageResource;
      this.isCustomImage = params.isCustomImage || false;
      this.isNetworkImage = params.isNetworkImage || false;
    }

    // åˆå§‹åŒ–åª’ä½“æŸ¥è¯¢
    this.initMediaQuery();

    // åˆå§‹åŒ–æ¸¸æˆ
    await this.initGame();
  }

  aboutToDisappear() {
    // ä¿å­˜æ¸¸æˆçŠ¶æ€
    if (this.isPlaying) {
      GameStorage.saveGameState({
        gameMode: this.gameMode,
        gridSize: this.gridSize,
        moveCount: this.moveCount,
        timeElapsed: this.timeElapsed,
        isPlaying: this.isPlaying
      });
    }

    // æ¸…ç†å®šæ—¶å™¨
    if (this.timerInterval !== -1) {
      clearInterval(this.timerInterval);
    }

    // æ¸…ç†åª’ä½“æŸ¥è¯¢
    if (this.listener) {
      this.listener.off('change');
    }
  }

  // åˆå§‹åŒ–åª’ä½“æŸ¥è¯¢ï¼ˆæŠ˜å å±é€‚é…ï¼‰
  private initMediaQuery(): void {
    this.listener = mediaquery.matchMediaSync(`(min-width: ${GameConstants.BREAKPOINT_WIDTH}vp)`);
    this.listener.on('change', (result) => {
      this.isWideScreen = result.matches;
    });
    this.isWideScreen = this.listener.matches;
  }

  // åˆå§‹åŒ–æ¸¸æˆ
  private async initGame(): Promise<void> {
    try {
      // åŠ è½½å›¾ç‰‡
      let pixelMap: image.PixelMap;
      if (this.isNetworkImage && typeof this.imageResource === 'string') {
        // ç½‘ç»œå›¾ç‰‡
        pixelMap = await UriConverter.urlToPixelMap(this.imageResource);
      } else if (this.isCustomImage && typeof this.imageResource === 'string') {
        // ç›¸å†Œå›¾ç‰‡
        pixelMap = await UriConverter.uriToPixelMap(this.imageResource);
      } else {
        // é¢„è®¾å›¾ç‰‡
        pixelMap = await UriConverter.resourceToPixelMap(this.imageResource as Resource);
      }

      this.originalPixelMap = pixelMap;

      // åˆ‡å‰²å›¾ç‰‡
      const tilesData = await ImageSlicer.sliceImage(pixelMap, this.gridSize);
      this.tiles = tilesData;
      this.emptyIndex = this.gridSize * this.gridSize - 1;

      // æ˜¾ç¤ºå®Œæ•´æ‹¼å›¾1ç§’åå¼€å§‹æ´—ç‰Œ
      setTimeout(() => {
        this.shuffleWithAnimation();
      }, 1000);

    } catch (error) {
      console.error('åˆå§‹åŒ–æ¸¸æˆå¤±è´¥:', error);
    }
  }

  // å¸¦åŠ¨ç”»çš„æ´—ç‰Œ
  private shuffleWithAnimation(): void {
    if (this.gameMode === GameConstants.GAME_MODE.HUARONG) {
      // åå®¹é“æ¨¡å¼ï¼šä½¿ç”¨ä¼ ç»Ÿæ´—ç‰Œ
      const result = ShuffleHelper.shuffle(this.tiles, this.gridSize);
      
      animateTo({
        duration: GameConstants.ANIMATION_DURATION.TILE_MOVE,
        curve: Curve.EaseOut
      }, () => {
        this.tiles = result.tiles;
        this.emptyIndex = result.emptyIndex;
      });
    } else {
      // äº¤æ¢æ¨¡å¼ï¼šå®Œå…¨éšæœºæ‰“ä¹±
      const shuffledTiles = ShuffleHelper.shuffleForSwapMode(this.tiles, this.gridSize);
      
      animateTo({
        duration: GameConstants.ANIMATION_DURATION.TILE_MOVE,
        curve: Curve.EaseOut
      }, () => {
        this.tiles = shuffledTiles;
      });
    }

    // æ´—ç‰Œå®Œæˆåå¼€å§‹è®¡æ—¶
    setTimeout(() => {
      this.startTimer();
    }, GameConstants.ANIMATION_DURATION.TILE_MOVE);
  }

  // å¼€å§‹è®¡æ—¶
  private startTimer(): void {
    this.isPlaying = true;
    this.timerInterval = setInterval(() => {
      if (this.isPlaying) {
        this.timeElapsed++;
      }
    }, 1000);
  }

  // ç‚¹å‡»æ–¹å—
  private onTileClick(index: number): void {
    if (!this.isPlaying) return;
    if (this.tiles[index].isEmpty) return;

    if (this.gameMode === GameConstants.GAME_MODE.HUARONG) {
      // åå®¹é“æ¨¡å¼ï¼šæ£€æŸ¥æ˜¯å¦ç›¸é‚»
      if (ShuffleHelper.isAdjacent(index, this.emptyIndex, this.gridSize)) {
        this.moveTile(index);
      }
    } else {
      // äº¤æ¢æ¨¡å¼ï¼šé€‰æ‹©æ–¹å—ç”¨äºäº¤æ¢
      if (this.selectedTileIndex === -1) {
        // ç¬¬ä¸€æ¬¡ç‚¹å‡»ï¼šé€‰ä¸­æ–¹å—
        this.selectedTileIndex = index;
      } else {
        // ç¬¬äºŒæ¬¡ç‚¹å‡»ï¼šäº¤æ¢æ–¹å—
        if (this.selectedTileIndex !== index) {
          this.swapTiles(this.selectedTileIndex, index);
        }
        this.selectedTileIndex = -1;
      }
    }
  }

  // äº¤æ¢ä¸¤ä¸ªæ–¹å—ï¼ˆäº¤æ¢æ¨¡å¼ï¼‰
  private swapTiles(index1: number, index2: number): void {
    // æ’­æ”¾ç§»åŠ¨éŸ³æ•ˆ
    SoundService.playMoveSound();

    animateTo({
      duration: GameConstants.ANIMATION_DURATION.TILE_MOVE,
      curve: Curve.EaseOut
    }, () => {
      // äº¤æ¢æ–¹å—
      const temp = this.tiles[index1];
      this.tiles[index1] = this.tiles[index2];
      this.tiles[index2] = temp;

      // æ›´æ–°currentIndex
      this.tiles[index1].currentIndex = index1;
      this.tiles[index2].currentIndex = index2;

      // æ­¥æ•°+1
      this.moveCount++;
    });

    // æ£€æŸ¥èƒœåˆ©
    setTimeout(() => {
      this.checkWin();
    }, GameConstants.ANIMATION_DURATION.TILE_MOVE);
  }

  // ç§»åŠ¨æ–¹å—
  private moveTile(index: number): void {
    // æ’­æ”¾ç§»åŠ¨éŸ³æ•ˆ
    SoundService.playMoveSound();

    // ä½¿ç”¨åŠ¨ç”»
    animateTo({
      duration: GameConstants.ANIMATION_DURATION.TILE_MOVE,
      curve: Curve.EaseOut
    }, () => {
      // äº¤æ¢
      const temp = this.tiles[index];
      this.tiles[index] = this.tiles[this.emptyIndex];
      this.tiles[this.emptyIndex] = temp;

      // æ›´æ–°ç´¢å¼•
      this.tiles[index].currentIndex = index;
      this.tiles[this.emptyIndex].currentIndex = this.emptyIndex;

      // æ›´æ–°ç©ºæ ¼ä½ç½®
      this.emptyIndex = index;

      // æ­¥æ•°+1
      this.moveCount++;
    });

    // æ£€æŸ¥èƒœåˆ©
    setTimeout(() => {
      this.checkWin();
    }, GameConstants.ANIMATION_DURATION.TILE_MOVE);
  }

  // æ£€æŸ¥èƒœåˆ©
  private checkWin(): void {
    if (WinChecker.checkWin(this.tiles)) {
      this.isPlaying = false;
      clearInterval(this.timerInterval);

      // ä¿å­˜æœ€ä½³è®°å½•
      GameStorage.saveBestRecord(this.gridSize, this.moveCount, this.timeElapsed);

      // æ¸…é™¤å½“å‰æ¸¸æˆçŠ¶æ€
      GameStorage.clearGameState();

      // æ’­æ”¾èƒœåˆ©åŠ¨ç”»
      this.playWinAnimation();
    }
  }

  // èƒœåˆ©åŠ¨ç”»
  private playWinAnimation(): void {
    // æ’­æ”¾èƒœåˆ©éŸ³æ•ˆ
    SoundService.playWinSound();

    // æ–¹å—é—´éš™é€æ¸æ¶ˆå¤±
    animateTo({
      duration: GameConstants.ANIMATION_DURATION.WIN,
      curve: Curve.EaseInOut
    }, () => {
      this.gridGap = 0;
    });

    // å»¶è¿Ÿæ˜¾ç¤ºå¯¹è¯æ¡†
    setTimeout(() => {
      this.winDialogController = new CustomDialogController({
        builder: WinDialog({
          moveCount: this.moveCount,
          timeElapsed: this.timeElapsed,
          onPlayAgain: () => {
            this.restartGame();
          },
          onBackHome: () => {
            this.goBackHome();
          }
        }),
        autoCancel: false,
        customStyle: true
      });
      this.winDialogController.open();
    }, GameConstants.ANIMATION_DURATION.WIN);
  }

  // é‡æ–°å¼€å§‹
  private restartGame(): void {
    // é‡ç½®çŠ¶æ€
    this.moveCount = 0;
    this.timeElapsed = 0;
    this.gridGap = GameConstants.GRID_GAP;
    
    // æ¸…é™¤å®šæ—¶å™¨
    if (this.timerInterval !== -1) {
      clearInterval(this.timerInterval);
    }

    // é‡æ–°æ´—ç‰Œ
    this.shuffleWithAnimation();
  }

  // ç»“æŸæ¸¸æˆï¼ˆæ˜¾ç¤ºç­”æ¡ˆï¼‰
  private endGame(): void {
    this.isPlaying = false;
    clearInterval(this.timerInterval);

    animateTo({
      duration: GameConstants.ANIMATION_DURATION.TILE_MOVE,
      curve: Curve.EaseOut
    }, () => {
      this.tiles = WinChecker.restoreAnswer(this.tiles);
      this.emptyIndex = this.gridSize * this.gridSize - 1;
      this.gridGap = 0;
    });
  }

  // è¿”å›ä¸»é¡µ
  private goBackHome(): void {
    try {
      router.back();
    } catch (err) {
      console.error('è¿”å›å¤±è´¥:', err);
    }
  }

  // æ ¼å¼åŒ–æ—¶é—´
  private formatTime(seconds: number): string {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  }

  // æ‹¼å›¾åŒºåŸŸ
  @Builder
  puzzleArea() {
    Stack() {
      // åº•å±‚åŸå›¾ï¼ˆå·çœ‹åŠŸèƒ½ï¼‰
      if (this.isPeeking && this.originalPixelMap) {
        Image(this.originalPixelMap)
          .width('100%')
          .height('100%')
          .objectFit(ImageFit.Cover)
          .opacity(0.5)
      }

      // æ‹¼å›¾ç½‘æ ¼
      Grid() {
        ForEach(this.tiles, (tile: TileData, index: number) => {
          GridItem() {
            if (tile.isEmpty) {
              // ç©ºæ ¼
              Column()
                .width('100%')
                .height('100%')
                .backgroundColor(GameConstants.COLORS.EMPTY_BG)
            } else {
              // æ–¹å—
              Stack() {
                // å›¾ç‰‡
                if (tile.pixelMap) {
                  Image(tile.pixelMap)
                    .width('100%')
                    .height('100%')
                    .objectFit(ImageFit.Fill)
                }

                // æ•°å­—æ ‡è®°
                Text((tile.id + 1).toString())
                  .fontSize(16)
                  .fontColor(GameConstants.COLORS.TEXT_OVERLAY)
                  .fontWeight(FontWeight.Bold)
                  .padding(4)
                  .backgroundColor('rgba(0, 0, 0, 0.5)')
                  .borderRadius(4)
                  .margin(4)

                // é€‰ä¸­çŠ¶æ€æŒ‡ç¤ºï¼ˆäº¤æ¢æ¨¡å¼ï¼‰
                if (this.gameMode === GameConstants.GAME_MODE.SWAP && this.selectedTileIndex === index) {
                  Column()
                    .width('100%')
                    .height('100%')
                    .backgroundColor('rgba(24, 144, 255, 0.3)')
                    .border({ width: 3, color: GameConstants.COLORS.PRIMARY })
                }
              }
              .width('100%')
              .height('100%')
              .backgroundColor(GameConstants.COLORS.TILE_BG)
              .alignContent(Alignment.TopStart)
              .onClick(() => {
                this.onTileClick(index);
              })
              .gesture(
                // æ‹–æ‹½æ‰‹åŠ¿ï¼ˆä»…äº¤æ¢æ¨¡å¼ï¼‰
                GestureGroup(GestureMode.Exclusive,
                  LongPressGesture({ repeat: false, duration: 300 })
                    .onAction(() => {
                      if (this.gameMode === GameConstants.GAME_MODE.SWAP && this.isPlaying) {
                        this.draggedTileIndex = index;
                      }
                    })
                )
              )
              .onDragStart(() => {
                if (this.gameMode === GameConstants.GAME_MODE.SWAP && this.isPlaying) {
                  this.draggedTileIndex = index;
                }
              })
              .onDrop((event) => {
                if (this.gameMode === GameConstants.GAME_MODE.SWAP && 
                    this.draggedTileIndex !== -1 && 
                    this.draggedTileIndex !== index) {
                  this.swapTiles(this.draggedTileIndex, index);
                  this.draggedTileIndex = -1;
                }
              })
            }
          }
        })
      }
      .columnsTemplate('1fr '.repeat(this.gridSize).trim())
      .rowsTemplate('1fr '.repeat(this.gridSize).trim())
      .columnsGap(this.gridGap)
      .rowsGap(this.gridGap)
      .width('100%')
      .height('100%')
      .backgroundColor('#CCCCCC')
    }
    .width('90%')
    .aspectRatio(1.0)
    .borderRadius(8)
    .shadow({ radius: 8, color: 'rgba(0, 0, 0, 0.1)' })
  }

  // æ§åˆ¶åŒºåŸŸ
  @Builder
  controlArea() {
    Column({ space: 16 }) {
      // ä¿¡æ¯æ 
      Row({ space: 20 }) {
        // è®¡æ—¶å™¨
        Column({ space: 4 }) {
          Text('â±ï¸')
            .fontSize(20)
          Text(this.formatTime(this.timeElapsed))
            .fontSize(18)
            .fontWeight(FontWeight.Bold)
            .fontColor(GameConstants.COLORS.TEXT)
        }

        // æ­¥æ•°
        Column({ space: 4 }) {
          Text('ğŸ‘£')
            .fontSize(20)
          Text(`${this.moveCount} æ­¥`)
            .fontSize(18)
            .fontWeight(FontWeight.Bold)
            .fontColor(GameConstants.COLORS.TEXT)
        }
      }
      .width('100%')
      .justifyContent(FlexAlign.SpaceEvenly)
      .padding(16)
      .backgroundColor(Color.White)
      .borderRadius(12)

      // å·çœ‹æŒ‰é’®
      Button() {
        Row({ space: 8 }) {
          Text('ğŸ‘ï¸')
            .fontSize(20)
          Text(this.isPeeking ? 'æ­£åœ¨å·çœ‹...' : 'å·çœ‹åŸå›¾')
            .fontSize(16)
        }
      }
      .width('100%')
      .height(44)
      .backgroundColor(this.isPeeking ? '#FFE7BA' : Color.White)
      .fontColor(GameConstants.COLORS.TEXT)
      .border({ width: 1, color: '#FFA500' })
      .onTouch((event) => {
        if (event.type === TouchType.Down) {
          animateTo({
            duration: GameConstants.ANIMATION_DURATION.PEEK_FADE,
            curve: Curve.EaseInOut
          }, () => {
            this.isPeeking = true;
          });
        } else if (event.type === TouchType.Up || event.type === TouchType.Cancel) {
          animateTo({
            duration: GameConstants.ANIMATION_DURATION.PEEK_FADE,
            curve: Curve.EaseInOut
          }, () => {
            this.isPeeking = false;
          });
        }
      })

      // æ¨¡å¼åˆ‡æ¢æŒ‰é’®
      Button() {
        Row({ space: 8 }) {
          Text('ğŸ”„')
            .fontSize(18)
          Text(this.gameMode === GameConstants.GAME_MODE.HUARONG ? 'åˆ‡æ¢åˆ°äº¤æ¢æ¨¡å¼' : 'åˆ‡æ¢åˆ°åå®¹é“æ¨¡å¼')
            .fontSize(14)
        }
      }
      .width('100%')
      .height(40)
      .backgroundColor(Color.White)
      .fontColor(GameConstants.COLORS.PRIMARY)
      .border({ width: 1, color: GameConstants.COLORS.PRIMARY, style: BorderStyle.Dashed })
      .onClick(() => {
        // åˆ‡æ¢æ¨¡å¼
        this.gameMode = this.gameMode === GameConstants.GAME_MODE.HUARONG ? 
          GameConstants.GAME_MODE.SWAP : GameConstants.GAME_MODE.HUARONG;
        // é‡æ–°å¼€å§‹æ¸¸æˆ
        this.restartGame();
      })

      // æ§åˆ¶æŒ‰é’®
      Row({ space: 12 }) {
        Button('é‡æ–°å¼€å§‹')
          .layoutWeight(1)
          .height(44)
          .fontSize(16)
          .backgroundColor('#52C41A')
          .onClick(() => {
            this.restartGame();
          })

        Button('ç»“æŸæ¸¸æˆ')
          .layoutWeight(1)
          .height(44)
          .fontSize(16)
          .backgroundColor('#FF4D4F')
          .onClick(() => {
            this.endGame();
          })
      }
      .width('100%')

      // è¿”å›ä¸»é¡µæŒ‰é’®
      Button('è¿”å›ä¸»é¡µ')
        .width('100%')
        .height(44)
        .fontSize(16)
        .backgroundColor(Color.White)
        .fontColor(GameConstants.COLORS.PRIMARY)
        .border({ width: 1, color: GameConstants.COLORS.PRIMARY })
        .onClick(() => {
          this.goBackHome();
        })
    }
    .width('100%')
    .padding(16)
  }

  build() {
    Column() {
      // æ ‡é¢˜æ 
      Row() {
        Column({ space: 2 }) {
          Text('ğŸ§© æ‹¼å›¾æ¸¸æˆ')
            .fontSize(20)
            .fontWeight(FontWeight.Bold)
            .fontColor(GameConstants.COLORS.TEXT)
          
          Text(this.gameMode === GameConstants.GAME_MODE.HUARONG ? 'åå®¹é“æ¨¡å¼' : 'è‡ªç”±äº¤æ¢æ¨¡å¼')
            .fontSize(12)
            .fontColor('#999999')
        }
      }
      .width('100%')
      .height(56)
      .padding({ left: 16, right: 16 })
      .backgroundColor(Color.White)
      .justifyContent(FlexAlign.Center)

      // ä¸»ä½“å†…å®¹
      if (this.isWideScreen) {
        // å®½å±å¸ƒå±€ï¼ˆæ¨ªå‘ï¼‰
        Row({ space: 16 }) {
          // å·¦ä¾§ï¼šæ‹¼å›¾åŒº
          Column() {
            this.puzzleArea()
          }
          .layoutWeight(7)
          .justifyContent(FlexAlign.Center)

          // å³ä¾§ï¼šæ§åˆ¶åŒº
          Column() {
            this.controlArea()
          }
          .layoutWeight(3)
        }
        .layoutWeight(1)
        .padding(16)
      } else {
        // çª„å±å¸ƒå±€ï¼ˆçºµå‘ï¼‰
        Column({ space: 16 }) {
          // ä¸Šæ–¹ï¼šæ‹¼å›¾åŒº
          Column() {
            this.puzzleArea()
          }
          .width('100%')
          .justifyContent(FlexAlign.Center)

          // ä¸‹æ–¹ï¼šæ§åˆ¶åŒº
          this.controlArea()
        }
        .layoutWeight(1)
        .padding(16)
      }
    }
    .width('100%')
    .height('100%')
    .backgroundColor(GameConstants.COLORS.BACKGROUND)
  }
}

